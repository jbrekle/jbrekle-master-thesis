\section{Evaluation}
\label{sec:evaluation}
Zu Evaluationswecken wurde eine TestCase mit PHPUnit erstellt\footnote{\url{<ow-repository>/erfurt/tests/Erfurt/Sparql/Query2Test.php}}, der verschiedene Methoden der Query-Klasse auf Korrektheit überprüft und Teil der Erfurt-TestSuite ist. Analoge Tests wurden für alle wichtigen Klassen erstellt, die zentrale Funktionalität bereitstellen, wie zum Beispiel die Element- und ContainerHelper.

\subsection{Laufzeitverhalten}
Ein Query2-Objekt ist eine Datenstruktur, die genutzt wird, um einen Query zu repräsentieren. Berechnungen finden hier kaum statt, daher ist es naheliegend, dass die Geschwindigkeit kein kritischer Punkt ist. Wenn man Beispiel \ref{code:example} sehr oft iteriert, ergibt sich eine durchschnittliche Laufzeit von je 0.0003 s --- also vernachlässigbar wenig. Vielmehr ist es interessant, den Speicherverbrauch zu betrachten: Dazu eignet sich die PHP-Funktion \texttt{memory\_get\_usage()}. Diese gibt den aktuellen Speicherverbrauch von PHP in Byte zurück. Eine Differenzmessung zeigt, dass ein Query-Objekt wie in Beispiel \ref{code:example} meist 17944 Byte verbraucht --- im Gegensatz dazu verbraucht die Anweisung \texttt{\$i="x"} genau 256 Byte. Man kann also von einem erheblichen Speicherverbrauch reden. Diese Messungen sind auch im Unit-Test zu finden und nachprüfbar.

\subsection{Korrektheit und Vollständigkeit}
Ziel der Arbeit war es, den bestehenden SPARQL-Standard (W3C Recommendation vom 25. Januar 2008) zu implementieren. Um die Erfüllung dieses Zieles zu verifizieren, sei wieder auf Rolland Brunecs Parser (\cite{rolland}) verwiesen, der meine Klassen als abstrakten Syntaxbaum nutzt. Um den Parser zu testen wurden dort die offiziellen DAWG Test-Cases\footnote{\url{http://www.w3.org/2001/sw/DataAccess/tests/r2}} verwendet. Mit der Korrektheit \& Vollständigkeit des Parsers ist dies implizit auch für meine Query-Klassen gezeigt. Der Test prüft nach dem Parsen, ob die String-Repräsentation des erstellten Query-Objekts der Eingabe entspricht. Die Tests\footnote{\url{erfurt/tests/Erfurt/Sparql/NewParserTest.php}} zeigen, dass der Standard vollständig und korrekt abgebildet ist.

\subsection{Verbesserungsmöglichkeiten}
Die Query Optimierung aus \ref{para:opt} könnte (wie in \cite{bernstein} vorgestellt) vervollständigt werden und statistische Daten über den Graph sammeln und bei der Optimierung mit einbeziehen.\\
Optimierungen wie die Elimination von tautologischen GraphPattern oder Anpassung an optimierte eigene Befehle verschiedener Datenbanksysteme sind ebenfalls denkbar. Jedoch sollte vorher geprüft werden, ob die jeweiligen Systeme eine solche Optimierung nicht schon selbst vornehmen.\\
Im Anschluss an diese Arbeit könnte die Erweiterung auf den neuen Standard SPARQL 1.1 Query vorgenommen werden. Dieser wird dann unter anderem Sub-Querys, Aggregatfunktionen und negierte GraphPattern ermöglichen sowie Updates beinhalten.\\
Die Erweiterung der Instanzliste um das Konzept des \emph{Set-based Browsing} (siehe \cite{parallax}) wäre ein weiterer Schritt, dem Nutzer Zusammenhänge in großen semantischen Datensammlungen zugänglich zu machen. Dieses Konzept ermöglicht es, von einer Menge (also einer Liste) von Instanzen zu einer anderen Menge von in Beziehung stehenden Instanzen zu navigieren. Konkret bedeutet das, dass man beispielsweise im show-properties-Modul die Möglichkeit erhält, über eine Property zu einer Liste der Werte zu gelangen. Diese Liste ist dann wiederum eine generische Instanzliste mit den eingeführten Filtermöglichkeiten etc. Diese Navigation ließe sich beliebig oft iterieren; der Verlauf könnte als lineare Folge von Knoten dargestellt werden --- mit der Möglichkeit, in dieser Historie hin- und herzuspringen. Beispielsweise könnte man eine Menge von Personen zunächst mit Filtern auf eine interessante Teilmenge einschränken. Dann kann man von dieser über eine Property zu einer Menge von anderen Personen springen, die jeweils eine gewisse Beziehung zu einer (oder mehreren) Person der Ursprungsmenge haben. Von dort aus könnte man zu weiteren verwandten Mengen navigieren. In Verbindung mit einem hypothetischen integrierten Statistik-Tool könnte man so Analysen auf relevanten Daten (bzw. auf komplexen Beziehungs-Netzwerken) ausführen, um Muster oder auffällige Zusammenhänge zu extrahieren.\\
Der Parser \cite{rolland} ermöglicht es, das Querys, die ein Nutzer im Query-Editor per Hand eingibt, in entsprechende Query2-Objekte umgewandelt werden und somit zur Listengenerierung genutzt werden können. Außerdem könnten diese und andere Querys nun gebookmarkt werden, indem die SPARQL-Stringrepräsentation als Parameter einer URL angefügt wird. Dieser könnte dann wiederum mit dem Parser verarbeitet werden. 

\newpage
